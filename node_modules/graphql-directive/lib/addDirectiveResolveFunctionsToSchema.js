'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _graphqlTools = require('graphql-tools');

var _graphql = require('graphql');

var _language = require('graphql/language');

var graphqlLanguage = _interopRequireWildcard(_language);

var _type = require('graphql/type');

var graphqlType = _interopRequireWildcard(_type);

var _execution = require('graphql/execution');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const DirectiveLocation = graphqlLanguage.DirectiveLocation || graphqlType.DirectiveLocation;

const BUILT_IN_DIRECTIVES = ['deprecated', 'skip', 'include'];

function getFieldResolver(field) {
  const resolver = field.resolve || _graphql.defaultFieldResolver;
  return resolver.bind(field);
}

function createAsyncResolver(field) {
  const originalResolver = getFieldResolver(field);
  return (() => {
    var _ref = _asyncToGenerator(function* (source, args, context, info) {
      return originalResolver(source, args, context, info);
    });

    return function (_x, _x2, _x3, _x4) {
      return _ref.apply(this, arguments);
    };
  })();
}

function getDirectiveInfo(directive, resolverMap, schema, location, variables) {
  const name = directive.name.value;

  const Directive = schema.getDirective(name);
  if (typeof Directive === 'undefined') {
    throw new Error(`Directive @${name} is undefined. ` + 'Please define in schema before using.');
  }

  if (!Directive.locations.includes(location)) {
    throw new Error(`Directive @${name} is not marked to be used on "${location}" location. ` + `Please add "directive @${name} ON ${location}" in schema.`);
  }

  const resolver = resolverMap[name];
  if (!resolver && !BUILT_IN_DIRECTIVES.includes(name)) {
    throw new Error(`Directive @${name} has no resolver.` + 'Please define one using createFieldExecutionResolver().');
  }

  const args = (0, _execution.getDirectiveValues)(Directive, { directives: [directive] }, variables);
  return { args, resolver };
}

function createFieldExecutionResolver(field, resolverMap, schema) {
  const directives = field.astNode.directives;

  if (!directives.length) return getFieldResolver(field);
  return directives.reduce((recursiveResolver, directive) => {
    const directiveInfo = getDirectiveInfo(directive, resolverMap, schema, DirectiveLocation.FIELD_DEFINITION);
    return (source, args, context, info) => directiveInfo.resolver(() => recursiveResolver(source, args, context, info), source, directiveInfo.args, context, info);
  }, createAsyncResolver(field));
}

function createFieldResolver(field, resolverMap, schema) {
  const originalResolver = getFieldResolver(field);
  const asyncResolver = createAsyncResolver(field);
  return (source, args, context, info) => {
    const directives = info.fieldNodes[0].directives;

    if (!directives.length) return originalResolver(source, args, context, info);
    const fieldResolver = directives.reduce((recursiveResolver, directive) => {
      const directiveInfo = getDirectiveInfo(directive, resolverMap, schema, DirectiveLocation.FIELD, info.variableValues);
      return () => directiveInfo.resolver(() => recursiveResolver(source, args, context, info), source, directiveInfo.args, context, info);
    }, asyncResolver);

    return fieldResolver(source, args, context, info);
  };
}

function addDirectiveResolveFunctionsToSchema(schema, resolverMap) {
  if (typeof resolverMap !== 'object') {
    throw new Error(`Expected resolverMap to be of type object, got ${typeof resolverMap}`);
  }

  if (Array.isArray(resolverMap)) {
    throw new Error('Expected resolverMap to be of type object, got Array');
  }

  (0, _graphqlTools.forEachField)(schema, field => {
    field.resolve = createFieldExecutionResolver(field, resolverMap, schema);
    field.resolve = createFieldResolver(field, resolverMap, schema);
  });
}

exports.default = addDirectiveResolveFunctionsToSchema;